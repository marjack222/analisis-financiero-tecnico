# -*- coding: utf-8 -*-
"""Appdeanalisisfundamentalytecnica2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16H3AostF9E99gj-IqD9eDSI-6_DoJxyK
"""

#Instalamos la libreria para hacer la conexion a la API

import matplotlib.pyplot as plt
import pandas as pd
import requests
import numpy as np
import ta
import yfinance as yf

# prompt:  incializar el dataframe lista_acciones

lista_acciones = pd.DataFrame()
lista_acciones

# prompt: Recode this last cell by checking if the ticker is valid without using AlphaVantage, using instead yfinance

lista_acciones = pd.DataFrame(columns=["Ticker"])

while True:
  ticker = input("Ingrese el ticker de la acción (o 'exit' para salir): ")
  if ticker.lower() == "exit":
    break
  try:
    # Use yfinance to check if the ticker is valid
    stock_info = yf.Ticker(ticker)
    # Attempt to get some basic info, if it fails, the ticker is likely invalid
    info = stock_info.info
    if info:
      # If the ticker is valid, save it in the dataframe
      lista_acciones.loc[len(lista_acciones)] = [ticker]
    else:
        print("Ticker inexistente. Intente nuevamente.")
  except Exception as e:
    print(f"Ticker inexistente. Intente nuevamente. Error: {e}")

print("Lista de acciones:")
lista_acciones

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
import numpy as np
def Ratiosfunc(ticker):
  try:
    stock = yf.Ticker(ticker)
    info = stock.info

    # Extract relevant ratios
    PERatio = info.get('trailingPE', np.nan) # Use .get() to avoid KeyError if ratio doesn't exist
    PriceToBookRatio = info.get('priceToBook', np.nan)
    PriceToSalesRatioTTM = info.get('priceToSalesTrailing12Months', np.nan)

    # Create a DataFrame
    df_ratios = pd.DataFrame({
        'PERatio': [PERatio],
        'PriceToBookRatio': [PriceToBookRatio],
        'PriceToSalesRatioTTM': [PriceToSalesRatioTTM],
        'Ticker': [ticker]
    })

    return df_ratios

  except Exception as e:
    print(f"Error getting data for ticker: {ticker}. Error: {e}")
    return None

df_ratios_lista_acciones = pd.DataFrame()
for ticker in lista_acciones["Ticker"]:
  df_ratios = Ratiosfunc(ticker)
  if df_ratios is not None:  # Check if data was retrieved successfully
    df_ratios_lista_acciones = pd.concat([df_ratios_lista_acciones, df_ratios], ignore_index=True)

df_ratios_lista_acciones

# prompt: Iterar sobre df_ratios_lista_acciones e intentar nuevamente obetener los datos faltantes

# Find tickers where ratios are missing
missing_ratios_tickers = df_ratios_lista_acciones[df_ratios_lista_acciones.isnull().any(axis=1)]['Ticker'].tolist()

# Iterate over the tickers with missing ratios and try to get the data again
for ticker in missing_ratios_tickers:
  print(f"Attempting to retrieve missing data for ticker: {ticker}")
  df_ratios = Ratiosfunc(ticker)
  if df_ratios is not None:
    # Update the row for this ticker in the main DataFrame
    df_ratios_lista_acciones.loc[df_ratios_lista_acciones['Ticker'] == ticker, ['PERatio', 'PriceToBookRatio', 'PriceToSalesRatioTTM']] = df_ratios[['PERatio', 'PriceToBookRatio', 'PriceToSalesRatioTTM']].values

print("Updated DataFrame with attempted retry for missing data:")
df_ratios_lista_acciones

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
import numpy as np
df_ingresosyganancias_lista_acciones = pd.DataFrame()
for ticker in lista_acciones["Ticker"]:
  try:
    stock = yf.Ticker(ticker)
    # Get income statement
    income_statement = stock.income_stmt

    # Check if there is enough data (at least 2 years for comparison)
    if income_statement is not None and len(income_statement.columns) > 1:
      # Get the last two columns (most recent two years)
      income_statement_last = income_statement.iloc[:, 0]
      income_statement_prev = income_statement.iloc[:, 1]

      # Create a DataFrame
      df_ingresosyganancias = pd.DataFrame({
          'netIncome': [income_statement_last.get("Net Income", np.nan)],
          'netIncome_prev': [income_statement_prev.get("Net Income", np.nan)],
          'totalRevenue': [income_statement_last.get("Total Revenue", np.nan)],
          'totalRevenue_prev': [income_statement_prev.get("Total Revenue", np.nan)],
          'Ticker': [ticker]
      })

      df_ingresosyganancias_lista_acciones = pd.concat([df_ingresosyganancias_lista_acciones, df_ingresosyganancias], ignore_index=True)
    else:
      print(f"Not enough income statement data (at least 2 years) for ticker: {ticker}")
  except Exception as e:
    print(f"Error fetching income statement for {ticker}: {e}")

df_ingresosyganancias_lista_acciones

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
import numpy as np
df_deuda_lista_acciones = pd.DataFrame()
for ticker in lista_acciones["Ticker"]:
  try:
    stock = yf.Ticker(ticker)

    # Get balance sheet
    balance_sheet = stock.balance_sheet
    # Get cash flow statement
    cashflow_statement = stock.cashflow
    # Get income statement
    income_statement = stock.income_stmt

    # Check if data is available and has at least one column (most recent period)
    if balance_sheet is not None and len(balance_sheet.columns) > 0 \
        and cashflow_statement is not None and len(cashflow_statement.columns) > 0 \
        and income_statement is not None and len(income_statement.columns) > 0:

      # Get the most recent period's data
      balance_sheet_last = balance_sheet.iloc[:, 0]
      cashflow_statement_last = cashflow_statement.iloc[:, 0]
      income_statement_last = income_statement.iloc[:, 0]

      # Create a DataFrame with desired fields
      df_deuda = pd.DataFrame({
          'longTermDebt': [balance_sheet_last.get('Long Term Debt', np.nan)],
          'totalAssets': [balance_sheet_last.get('Total Assets', np.nan)],
          'totalShareholderEquity': [balance_sheet_last.get('Total Stockholder Equity', np.nan)],
          'operatingCashflow': [cashflow_statement_last.get('Operating Cash Flow', np.nan)],
          'interestAndDebtExpense': [income_statement_last.get('Interest Expense', np.nan)], # yfinance names it 'Interest Expense'
          'Ticker': [ticker]
      })

      df_deuda_lista_acciones = pd.concat([df_deuda_lista_acciones, df_deuda], ignore_index=True)

    else:
      print(f"Not enough data for ticker: {ticker} in balance sheet, cashflow, or income statement.")

  except Exception as e:
    print(f"Error getting data for ticker: {ticker}. Error: {e}")

df_deuda_lista_acciones

import requests

API_KEY = 'AsTWXrQylhaYGPEzXVMYV2lLO6Mq0Jgp'  # Sustituye esto con tu API Key real
symbol = 'AAPL'  # Cambia por el símbolo de la empresa que desees

url = f'https://financialmodelingprep.com/api/v3/balance-sheet-statement/{symbol}?limit=1&apikey={API_KEY}'

response = requests.get(url)
data = response.json()

# Accede al campo totalStockholdersEquity del reporte más reciente
equity = data[0]['totalStockholdersEquity']
print(f"Total Shareholder Equity de {symbol}: {equity}")

# prompt: Buscar "Total Shareholder Equity" en financialmodelingprep para cada Ticker en df_deuda_lista_acciones y agregar el valor al campo totalShareholderEquity

import numpy as np
# Asegúrate de tener la columna 'totalShareholderEquity' en tu DataFrame si no existe
if 'totalShareholderEquity' not in df_deuda_lista_acciones.columns:
    df_deuda_lista_acciones['totalShareholderEquity'] = np.nan

API_KEY = 'AsTWXrQylhaYGPEzXVMYV2lLO6Mq0Jgp'  # Sustituye esto con tu API Key real

for index, row in df_deuda_lista_acciones.iterrows():
    ticker = row['Ticker']
    url = f'https://financialmodelingprep.com/api/v3/balance-sheet-statement/{ticker}?limit=1&apikey={API_KEY}'

    try:
        response = requests.get(url)
        data = response.json()

        if data and 'totalStockholdersEquity' in data[0]:
            # Accede al campo totalStockholdersEquity del reporte más reciente
            equity = data[0]['totalStockholdersEquity']
            df_deuda_lista_acciones.at[index, 'totalShareholderEquity'] = equity
            print(f"Total Shareholder Equity de {ticker}: {equity}")
        else:
            print(f"No se encontró 'totalStockholdersEquity' o datos para {ticker} en Financial Modeling Prep API.")

    except Exception as e:
        print(f"Error al obtener datos para {ticker} de Financial Modeling Prep API: {e}")

print("\nDataFrame con Total Shareholder Equity actualizado:")
df_deuda_lista_acciones

# prompt: Tomando esta ultima celda # Calcula las relaciones financieras para cada ticker en df_deuda_lista_acciones y generar un nuevo dataframe llamado df_deuda_lista_acciones_ratios. Luego con # Puntuación basada en las relaciones generar un score para cada ticker y guardarlo en una nueva columna.

import pandas as pd
import numpy as np # Import numpy for handling NaN

# Convert relevant columns to numeric before iteration, handling errors and filling NaN
df_deuda_lista_acciones_processed = df_deuda_lista_acciones.copy()
for col in ["longTermDebt", "totalAssets", "totalShareholderEquity", "operatingCashflow", "interestAndDebtExpense"]:
    df_deuda_lista_acciones_processed[col] = pd.to_numeric(df_deuda_lista_acciones_processed[col], errors='coerce').fillna(0.0)

# Calcula las relaciones financieras para cada ticker en df_deuda_lista_acciones
df_deuda_lista_acciones_ratios = pd.DataFrame(columns=["Ticker", "debt_to_asset_ratio", "debt_to_equity_ratio", "interest_coverage_ratio", "debt_to_cash_flow_ratio"]) # Initialize DataFrame with columns

for index, row in df_deuda_lista_acciones_processed.iterrows():
  # Now the values in row are already numeric and NaNs are filled
  long_term_debt = row["longTermDebt"]
  total_assets = row["totalAssets"]
  total_equity = row["totalShareholderEquity"]
  operating_cash_flow = row["operatingCashflow"]
  interest_expense = row["interestAndDebtExpense"] # Use the processed column name


  # Avoid division by zero
  if total_assets != 0:
    debt_to_asset_ratio = long_term_debt / total_assets
  else:
    debt_to_asset_ratio = 0.0  # Or another appropriate value

  if total_equity != 0:
    debt_to_equity_ratio = long_term_debt / total_equity
  else:
    debt_to_equity_ratio = 0.0  # Or another appropriate value

  # Avoid division by zero if interest_expense is zero
  if interest_expense != 0 and not np.isnan(interest_expense): # Also check for NaN
    interest_coverage_ratio = operating_cash_flow / interest_expense
  else:
    interest_coverage_ratio = float('inf')  # Or another appropriate value

  if operating_cash_flow != 0 and not np.isnan(operating_cash_flow): # Also check for NaN
    debt_to_cash_flow_ratio = long_term_debt / operating_cash_flow
  else:
    debt_to_cash_flow_ratio = 0.0  # Or another appropriate value

  df_deuda_lista_acciones_ratios.loc[index] = { # Now you can assign values using .loc
    "Ticker": row["Ticker"],
    "debt_to_asset_ratio": debt_to_asset_ratio,
    "debt_to_equity_ratio": debt_to_equity_ratio,
    "interest_coverage_ratio": interest_coverage_ratio,
    "debt_to_cash_flow_ratio": debt_to_cash_flow_ratio
  }

# Puntuación basada en las relaciones
df_deuda_lista_acciones_ratios["score"] = 10

for index, row in df_deuda_lista_acciones_ratios.iterrows():
  debt_to_asset_ratio = row["debt_to_asset_ratio"]
  debt_to_equity_ratio = row["debt_to_equity_ratio"]
  interest_coverage_ratio = row["interest_coverage_ratio"]
  debt_to_cash_flow_ratio = row["debt_to_cash_flow_ratio"]

  if debt_to_asset_ratio > 0.5:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 2
  elif debt_to_asset_ratio > 0.3:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 1

  if debt_to_equity_ratio > 1:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 2
  elif debt_to_equity_ratio > 0.5:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 1

  if interest_coverage_ratio < 2:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 2
  elif interest_coverage_ratio < 5:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 1

  if debt_to_cash_flow_ratio > 5:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 2
  elif debt_to_cash_flow_ratio > 3:
    df_deuda_lista_acciones_ratios.loc[index, "score"] -= 1

print(df_deuda_lista_acciones_ratios)

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
import numpy as np
def get_financial_ratios(symbol):
  try:
    stock = yf.Ticker(symbol)
    info = stock.info

    # Get current price
    current_price = info.get('currentPrice', np.nan)

    # Get relevant information for ratio calculation
    earnings_per_share = info.get('trailingEPS', np.nan)
    book_value_per_share = info.get('bookValue', np.nan)
    revenue_per_share = info.get('revenuePerShare', np.nan) # yfinance provides this directly
    total_revenue = info.get('totalRevenue', np.nan)
    shares_outstanding = info.get('sharesOutstanding', np.nan)

    # Calculate ratios, handle division by zero and NaN
    pe_ratio = current_price / earnings_per_share if earnings_per_share and earnings_per_share != 0 else np.nan
    pb_ratio = current_price / book_value_per_share if book_value_per_share and book_value_per_share != 0 else np.nan

    # Calculate PS Ratio - use revenue per share if available, otherwise calculate from total revenue and shares outstanding
    if revenue_per_share and revenue_per_share != 0:
        ps_ratio = current_price / revenue_per_share
    elif total_revenue and shares_outstanding and shares_outstanding != 0:
        ps_ratio = current_price / (total_revenue / shares_outstanding)
    else:
        ps_ratio = np.nan


    return pe_ratio, pb_ratio, ps_ratio

  except Exception as e:
    print(f"Error getting financial data for {symbol}: {e}")
    return np.nan, np.nan, np.nan # Return NaN for all ratios on error

# Function to interpret ratios remains the same
def interpret_ratios(pe_ratio, pb_ratio, ps_ratio):
    interpretation = {}

    # Interpretar P/E ratio
    if pd.notna(pe_ratio):
        if pe_ratio < 15:
            interpretation['P/E Ratio'] = "Undervalued"
        elif 15 <= pe_ratio <= 25:
            interpretation['P/E Ratio'] = "Fairly valued"
        else:
            interpretation['P/E Ratio'] = "Overvalued"
    else:
        interpretation['P/E Ratio'] = "Not Available"

    # Interpretar P/B ratio
    if pd.notna(pb_ratio):
        if pb_ratio < 1:
            interpretation['P/B Ratio'] = "Undervalued"
        elif 1 <= pb_ratio <= 3:
            interpretation['P/B Ratio'] = "Fairly valued"
        else:
            interpretation['P/B Ratio'] = "Overvalued"
    else:
        interpretation['P/B Ratio'] = "Not Available"

    # Interpretar P/S ratio
    if pd.notna(ps_ratio):
        if ps_ratio < 1:
            interpretation['P/S Ratio'] = "Undervalued"
        elif 1 <= ps_ratio <= 2:
            interpretation['P/S Ratio'] = "Fairly valued"
        else:
            interpretation['P/S Ratio'] = "Overvalued"
    else:
        interpretation['P/S Ratio'] = "Not Available"


    return interpretation

# Example of use (you can iterate through lista_acciones['Ticker'] here)
# For a single ticker:
#symbol = 'MSFT'  # Replace with the stock symbol you want to analyze
#pe_ratio, pb_ratio, ps_ratio = get_financial_ratios(symbol)
#interpretation = interpret_ratios(pe_ratio, pb_ratio, ps_ratio)

#print(f"Ratios financieros para {symbol}:")
#print(f"P/E Ratio: {pe_ratio} - {interpretation['P/E Ratio']}")
#print(f"P/B Ratio: {pb_ratio} - {interpretation['P/B Ratio']}")
#print(f"P/S Ratio: {ps_ratio} - {interpretation['P/S Ratio']}")

# To apply to all tickers in lista_acciones:
# financial_interpretations = {}
# for ticker in lista_acciones['Ticker']:
#     pe, pb, ps = get_financial_ratios(ticker)
#     interp = interpret_ratios(pe, pb, ps)
#     financial_interpretations[ticker] = {
#         'PE_Ratio': pe, 'PE_Interpretation': interp['P/E Ratio'],
#         'PB_Ratio': pb, 'PB_Interpretation': interp['P/B Ratio'],
#         'PS_Ratio': ps, 'PS_Interpretation': interp['P/S Ratio']
#     }
#
# # Convert to DataFrame for easier viewing
# df_financial_interpretations = pd.DataFrame.from_dict(financial_interpretations, orient='index')
# print(df_financial_interpretations)

# prompt: codificar para cada ticker del dataframe df_ratios_lista_acciones y generar un nuevo dataframe llamado interpretacion_ratios con el resultado de # Interpretar P/E ratio, # Interpretar P/B ratio, # Interpretar P/S ratio

import pandas as pd
#API_KEY = '3PSTOUJFRVB0NHCF'
interpretacion_ratios = pd.DataFrame(columns=["Ticker", "P/E Ratio", "P/B Ratio", "P/S Ratio"])

for index, row in df_ratios_lista_acciones.iterrows():
  ticker = row["Ticker"]
  # Convert financial ratios to floats, handling 'None' and '-' values
  pe_ratio = float(row["PERatio"]) if row["PERatio"] not in ['None', 'inf', '-'] else None # Changed to include 'None'
  pb_ratio = float(row["PriceToBookRatio"]) if row["PriceToBookRatio"] not in ['None', 'inf', '-'] else None # Changed to include 'None'
  ps_ratio = float(row["PriceToSalesRatioTTM"]) if row["PriceToSalesRatioTTM"] not in ['None', 'inf', '-'] else None # Changed to include 'None'

  # Handle cases where ratios might be None
  if pe_ratio is not None and pb_ratio is not None and ps_ratio is not None:
      interpretation = interpret_ratios(pe_ratio, pb_ratio, ps_ratio)

      interpretacion_ratios.loc[index] = {
          "Ticker": ticker,
          "P/E Ratio": interpretation["P/E Ratio"],
          "P/B Ratio": interpretation["P/B Ratio"],
          "P/S Ratio": interpretation["P/S Ratio"]
      }
  else:
      print(f"Warning: Missing financial data for {ticker}. Skipping...")

print(interpretacion_ratios)

# prompt: modificar el codigo para que tome los valores de df_ingresosyganancias_lista_acciones y calculate_growth tome los valores actuales y anteriores

import pandas as pd
interpretacion_ingresos_y_ganancias = pd.DataFrame(columns=["Ticker", "Revenue Growth", "Net Income Growth"])

# Función para calcular el crecimiento
def calculate_growth(current_value, previous_value):
    if previous_value == 0:
        return 0  # Avoid division by zero
    growth = (current_value - previous_value) / previous_value
    return growth

# Función para interpretar el crecimiento
def interpret_growth(revenue_growth, net_income_growth):
    interpretation = {}

    # Interpretar crecimiento de ingresos
    if revenue_growth > 0.15:
        interpretation['Revenue Growth'] = "Strong growth"
    elif 0.05 <= revenue_growth <= 0.15:
        interpretation['Revenue Growth'] = "Moderate growth"
    else:
        interpretation['Revenue Growth'] = "Weak growth"

    # Interpretar crecimiento de ganancias netas
    if net_income_growth > 0.15:
        interpretation['Net Income Growth'] = "Strong growth"
    elif 0.05 <= net_income_growth <= 0.15:
        interpretation['Net Income Growth'] = "Moderate growth"
    else:
        interpretation['Net Income Growth'] = "Weak growth"

    return interpretation

for index, row in df_ingresosyganancias_lista_acciones.iterrows():
    ticker = row["Ticker"]
    current_revenue = float(row["totalRevenue"])
    current_net_income = float(row["netIncome"])

    # Handle 'None' values for previous revenue
    previous_revenue_str = df_ingresosyganancias_lista_acciones.loc[index, "totalRevenue_prev"]
    previous_revenue = float(previous_revenue_str) if previous_revenue_str != 'None' else 0.0

    # Handle 'None' values for previous net income
    previous_net_income_str = df_ingresosyganancias_lista_acciones.loc[index, "netIncome_prev"]
    previous_net_income = float(previous_net_income_str) if previous_net_income_str != 'None' else 0.0

    # Calculate growth rates
    revenue_growth = calculate_growth(current_revenue, previous_revenue)
    net_income_growth = calculate_growth(current_net_income, previous_net_income)

    interpretation = interpret_growth(revenue_growth, net_income_growth)

    interpretacion_ingresos_y_ganancias.loc[index] = {
        "Ticker": ticker,
        "Revenue Growth": interpretation["Revenue Growth"],
        "Net Income Growth": interpretation["Net Income Growth"]
    }

print(interpretacion_ingresos_y_ganancias)

# prompt: moficar el codigo y agregar : Si factor_analisis = "Ingresos y ganancias" devolver df_ingresosyganancias_lista_acciones y interpretacion_ingresos_y_ganancias. factor_analisis = "Ratios financieros" devolver df_ratios_lista_acciones y interpretacion_ratios. Si factor_analisis = "Deuda" devolver df_deuda_lista_acciones_ratios

while True:
  factor_analisis = input("¿Qué factor analizamos? (1- Ingresos y ganancias, 2- Ratios financieros, 3- Deuda, 'exit' para salir): ")
  if factor_analisis == "exit":
    break
  elif factor_analisis == "1":
    factor_analisis = "Ingresos y ganancias"
    print(df_ingresosyganancias_lista_acciones)
    print(interpretacion_ingresos_y_ganancias)
    break
  elif factor_analisis == "2":
    factor_analisis = "Ratios financieros"
    print(df_ratios_lista_acciones)
    print(interpretacion_ratios)
    break
  elif factor_analisis == "3":
    factor_analisis = "Deuda"
    print(df_deuda_lista_acciones_ratios)
    break
  else:
    print("Opción inválida. Intente nuevamente.")

# prompt: Unir los dataframes df_ingresosyganancias_lista_acciones y interpretacion_ingresos_y_ganancias en uno solo llamarlo Resultado_analisis_fundamental_IG

import pandas as pd
Resultado_analisis_fundamental_IG = pd.merge(df_ingresosyganancias_lista_acciones, interpretacion_ingresos_y_ganancias, on="Ticker")
Resultado_analisis_fundamental_RF = pd.merge(df_ratios_lista_acciones, interpretacion_ratios, on="Ticker")

Resultado_analisis_fundamental_IG

Resultado_analisis_fundamental_RF

# prompt: Para cada ticker en interpretacion_ingresos_y_ganancias Realizar un analisis segun su Revenue Growth y Net Income y Growth y devolverlo en un dataframe llamado sugerencia_ingresosyganancias

import pandas as pd

def analyze_growth(revenue_growth, net_income_growth):
    if revenue_growth == "Strong growth" and net_income_growth == "Strong growth":
        return "Buy"
    elif revenue_growth == "Moderate growth" and net_income_growth == "Moderate growth":
        return "Hold"
    elif revenue_growth == "Weak growth" and net_income_growth == "Weak growth":
        return "Sell"
    else:
        return "Neutral"

sugerencia_ingresosyganancias = pd.DataFrame(columns=["Ticker", "Sugerencia_ingresosyganancias"])

for index, row in interpretacion_ingresos_y_ganancias.iterrows():
    ticker = row["Ticker"]
    revenue_growth = row["Revenue Growth"]
    net_income_growth = row["Net Income Growth"]
    suggestion = analyze_growth(revenue_growth, net_income_growth)

    sugerencia_ingresosyganancias.loc[index] = {
        "Ticker": ticker,
        "Sugerencia_ingresosyganancias": suggestion
    }

print(sugerencia_ingresosyganancias)

# prompt: Para cada ticker en interpretacion_ratios Realizar un analisis segun los ratios y devolverlo en un dataframe llamado sugerencia_ratiosfinancieros

import pandas as pd
def analyze_ratios(pe_ratio, pb_ratio, ps_ratio):
    if pe_ratio == "Undervalued" and pb_ratio == "Undervalued" and ps_ratio == "Undervalued":
        return "Buy"
    elif pe_ratio == "Fairly valued" and pb_ratio == "Fairly valued" and ps_ratio == "Fairly valued":
        return "Hold"
    elif pe_ratio == "Overvalued" and pb_ratio == "Overvalued" and ps_ratio == "Overvalued":
        return "Sell"
    else:
        return "Neutral"

sugerencia_ratiosfinancieros = pd.DataFrame(columns=["Ticker", "Sugerencia_ratiosfinancieros"])

for index, row in interpretacion_ratios.iterrows():
    ticker = row["Ticker"]
    pe_ratio = row["P/E Ratio"]
    pb_ratio = row["P/B Ratio"]
    ps_ratio = row["P/S Ratio"]
    suggestion = analyze_ratios(pe_ratio, pb_ratio, ps_ratio)

    sugerencia_ratiosfinancieros.loc[index] = {
        "Ticker": ticker,
        "Sugerencia_ratiosfinancieros": suggestion
    }

print(sugerencia_ratiosfinancieros)

# prompt: Para cada ticker en df_deuda_lista_acciones_ratios Realizar un analisis segun los ratios y score y devolverlo en un dataframe llamado sugerencia_deuda

import pandas as pd
def analyze_debt(debt_to_asset_ratio, debt_to_equity_ratio, interest_coverage_ratio, debt_to_cash_flow_ratio, score):
    if score >= 8:
        return "Buy"
    elif 5 <= score <= 7:
        return "Hold"
    else:
        return "Sell"

sugerencia_deuda = pd.DataFrame(columns=["Ticker", "Sugerencia_deuda"])

for index, row in df_deuda_lista_acciones_ratios.iterrows():
    ticker = row["Ticker"]
    debt_to_asset_ratio = row["debt_to_asset_ratio"]
    debt_to_equity_ratio = row["debt_to_equity_ratio"]
    interest_coverage_ratio = row["interest_coverage_ratio"]
    debt_to_cash_flow_ratio = row["debt_to_cash_flow_ratio"]
    score = row["score"]
    suggestion = analyze_debt(debt_to_asset_ratio, debt_to_equity_ratio, interest_coverage_ratio, debt_to_cash_flow_ratio, score)

    sugerencia_deuda.loc[index] = {
        "Ticker": ticker,
        "Sugerencia_deuda": suggestion
    }

print(sugerencia_deuda)

# prompt: Crear un nuevo dataframe llamado df_sugerencias_analisisfundamental con cada ticker de lista_acciones, agregar las columnas : "sugerencia_ingresosyganancias" tomando el dato del dataframe sugerencia_ingresosyganancias "sugerencia_ratiosfinancieros" tomando el dato del dataframe con mismo nombre y otra columna llamada "sugerencia_deuda" tomando el dato del dataframe  sugerencia_deuda .

# prompt: Crear un nuevo dataframe llamado df_sugerencias_analisisfundamental con cada ticker de lista_acciones, agregar las columnas : "sugerencia_ingresosyganancias" tomando el dato del dataframe sugerencia_ingresosyganancias "sugerencia_ratiosfinancieros" tomando el dato del dataframe con mismo nombre y otra columna llamada "sugerencia_deuda" tomando el dato del dataframe  sugerencia_deuda .

import pandas as pd
df_sugerencias_analisisfundamental = pd.DataFrame(columns=["Ticker", "sugerencia_ingresosyganancias", "sugerencia_ratiosfinancieros", "sugerencia_deuda"])

# Use a list to store the data and then create a DataFrame
data = []
for ticker in lista_acciones["Ticker"]:
    # Handle cases where ticker might not be in all DataFrames
    sugerencia_ingresos = sugerencia_ingresosyganancias[sugerencia_ingresosyganancias["Ticker"] == ticker]["Sugerencia_ingresosyganancias"].values[0] if ticker in sugerencia_ingresosyganancias["Ticker"].values else None
    sugerencia_ratios = sugerencia_ratiosfinancieros[sugerencia_ratiosfinancieros["Ticker"] == ticker]["Sugerencia_ratiosfinancieros"].values[0] if ticker in sugerencia_ratiosfinancieros["Ticker"].values else None
    sugerencia_deuda_val = sugerencia_deuda[sugerencia_deuda["Ticker"] == ticker]["Sugerencia_deuda"].values[0] if ticker in sugerencia_deuda["Ticker"].values else None

    data.append({
        "Ticker": ticker,
        "sugerencia_ingresosyganancias": sugerencia_ingresos,
        "sugerencia_ratiosfinancieros": sugerencia_ratios,
        "sugerencia_deuda": sugerencia_deuda_val
    })

# Create the DataFrame from the list
df_sugerencias_analisisfundamental = pd.DataFrame(data)

print(df_sugerencias_analisisfundamental)

df_sugerencias_analisisfundamental

# prompt: Recodificar la ultima celda , cuando el resultado es "Sell" restar un punto y cuando es "Neutral" sumar un punto

def calculate_score(row):
  score = 0
  if row["sugerencia_ingresosyganancias"] == "Sell":
    score -= 1
  elif row["sugerencia_ingresosyganancias"] == "Neutral":
    score += 1
  elif row["sugerencia_ingresosyganancias"] == "Buy":
    score += 3
  elif row["sugerencia_ingresosyganancias"] == "Hold":
    score += 2

  if row["sugerencia_ratiosfinancieros"] == "Sell":
    score -= 1
  elif row["sugerencia_ratiosfinancieros"] == "Neutral":
    score += 1
  elif row["sugerencia_ratiosfinancieros"] == "Buy":
    score += 3
  elif row["sugerencia_ratiosfinancieros"] == "Hold":
    score += 2

  if row["sugerencia_deuda"] == "Sell":
    score -= 1
  elif row["sugerencia_deuda"] == "Neutral":
    score += 1
  elif row["sugerencia_deuda"] == "Buy":
    score += 3
  elif row["sugerencia_deuda"] == "Hold":
    score += 2

  return score

df_sugerencias_analisisfundamental["Score_Fundamental"] = df_sugerencias_analisisfundamental.apply(calculate_score, axis=1)

print(df_sugerencias_analisisfundamental)

# prompt: Resultado_analisis_fundamental_IG, Resultado_analisis_fundamental_RF, df_deuda_lista_acciones_ratios,df_sugerencias_analisisfundamental, juntar todos en un nuevo dataframe llamado df_analisisfundamental_total. Un dataframe por hoja.

df_analisisfundamental_total = pd.DataFrame()

# Concatenate all dataframes
df_analisisfundamental_total = pd.concat([Resultado_analisis_fundamental_IG, Resultado_analisis_fundamental_RF, df_deuda_lista_acciones_ratios, df_sugerencias_analisisfundamental], axis=1)

# Create a new Excel file
with pd.ExcelWriter('Analisis_fundamental_total.xlsx', engine='xlsxwriter') as writer:
    # Write each dataframe to a separate sheet
    Resultado_analisis_fundamental_IG.to_excel(writer, sheet_name='Ingresos y ganancias')
    Resultado_analisis_fundamental_RF.to_excel(writer, sheet_name='Ratios financieros')
    df_deuda_lista_acciones_ratios.to_excel(writer, sheet_name='Deuda')
    df_sugerencias_analisisfundamental.to_excel(writer, sheet_name='Sugerencias')

# Close the Excel file writer object to save the file
writer.close() # Use close() instead of save()

# prompt: print "El puntaje va de -3 a 9"

print("El puntaje va de -3 a 9")

df_analisisfundamental_total

"""Aquí comienza el analisis técnico"""

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
import matplotlib.pyplot as plt
# Aquí comienza el analisis técnico

# Función para obtener datos históricos
def get_historical_data_yf(symbol):
    try:
        stock = yf.Ticker(symbol)
        # Get daily historical data
        data = stock.history(period="1y") # Fetch data for the last 1 year
        data = data.sort_index()  # Ensure data is sorted by date
        # Rename columns to match the expected format if necessary (yfinance uses different names)
        data = data.rename(columns={'Close': '4. close', 'Open': '1. open', 'High': '2. high', 'Low': '3. low', 'Volume': '5. volume'})
        return data
    except Exception as e:
        print(f"Error getting historical data for {symbol}: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error

# Function to calculate moving averages and RSI using 'ta' library
def calculate_indicators_ta(data, short_window=20, long_window=50):
    if data.empty or '4. close' not in data.columns:
        return pd.DataFrame() # Return empty if data is not valid

    # Use the 'ta' library for technical indicators
    data['SMA20'] = ta.trend.sma_indicator(data['4. close'], window=short_window)
    data['SMA50'] = ta.trend.sma_indicator(data['4. close'], window=long_window)
    data['RSI'] = ta.momentum.rsi(data['4. close'], window=14)
    return data

# Function to determine the trend
def identify_trend_yf(data):
    if data.empty or 'SMA20' not in data.columns or 'SMA50' not in data.columns:
        return 'Indeterminada' # Return indeterminada if data or indicators are missing

    # Ensure the latest values are not NaN before comparison
    if pd.notna(data['SMA20'].iloc[-1]) and pd.notna(data['SMA50'].iloc[-1]):
        if data['SMA20'].iloc[-1] > data['SMA50'].iloc[-1]:
            return 'Alcista'
        elif data['SMA20'].iloc[-1] < data['SMA50'].iloc[-1]:
            return 'Bajista'
        else:
            return 'Indeterminada'
    else:
        return 'Indeterminada'


# Function to plot the data and moving averages
def plot_data_yf(data, symbol):
    if data.empty or '4. close' not in data.columns:
        print(f"No valid data to plot for {symbol}")
        return

    plt.figure(figsize=(12, 6))
    plt.plot(data.index, data['4. close'], label='Precio de Cierre')
    if 'SMA20' in data.columns:
        plt.plot(data.index, data['SMA20'], label='SMA 20')
    if 'SMA50' in data.columns:
        plt.plot(data.index, data['SMA50'], label='SMA 50')

    plt.title(f'Tendencia de Precios para {symbol}')
    plt.xlabel('Fecha')
    plt.ylabel('Precio')
    plt.legend()
    plt.show()


# Example of use (you can iterate through lista_acciones['Ticker'] here)
# For a single ticker:
#symbol = 'MSFT'  # Replace with the stock symbol you want to analyze
#data = get_historical_data_yf(symbol)
#if not data.empty:
#    data = calculate_indicators_ta(data)
#    trend = identify_trend_yf(data)
#
#    print(f"La tendencia de precios para {symbol} es: {trend}")
#    plot_data_yf(data, symbol)
#else:
#    print(f"Could not retrieve historical data for {symbol}")
#
# To apply to all tickers in lista_acciones:
# technical_analysis_results = {}
# for ticker in lista_acciones['Ticker']:
#     data = get_historical_data_yf(ticker)
#     if not data.empty:
#         data = calculate_indicators_ta(data)
#         trend = identify_trend_yf(data)
#         technical_analysis_results[ticker] = {'Trend': trend}
#     else:
#         technical_analysis_results[ticker] = {'Trend': 'Data Not Available'}
#
# df_technical_analysis = pd.DataFrame.from_dict(technical_analysis_results, orient='index')
# print(df_technical_analysis)

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
df_tendencia_diaria = pd.DataFrame(columns=["Ticker", "Tendencia"])

for ticker in lista_acciones["Ticker"]:
    # Obtener datos históricos usando yfinance
    data = get_historical_data_yf(ticker)

    if not data.empty:
        # Calcular indicadores usando 'ta' library
        data = calculate_indicators_ta(data)

        # Identificar tendencia
        trend = identify_trend_yf(data)
    else:
        trend = "Indeterminada" # Assign "Indeterminada" if data is not available

    # Añadir fila al DataFrame
    df_tendencia_diaria = pd.concat([df_tendencia_diaria, pd.DataFrame({"Ticker": [ticker], "Tendencia": [trend]})], ignore_index=True)

# Imprimir el DataFrame
df_tendencia_diaria

# prompt: Recode this last cell using yfinance instead AlphaVantage

import pandas as pd
df_datos_1h = pd.DataFrame()

# Iterate over each ticker in the lista_acciones DataFrame
for index, row in lista_acciones.iterrows():
    ticker = row['Ticker']

    try:
        # Get intraday data with 60-minute intervals using yfinance
        stock = yf.Ticker(ticker)
        # Use .history() for historical intraday data. yfinance doesn't directly support 60-min intervals like AlphaVantage's intraday.
        # The closest options might be 1h or 90m if available, or using 30m and resampling.
        # Let's try 1h if yfinance supports it directly, otherwise we might need a different approach or use a shorter interval and resample.
        # As of recent yfinance versions, '1h' is a supported interval.
        data = stock.history(period="1mo", interval="1h") # Get 1 month of 1-hour data

        if not data.empty:
            # Add the ticker as a new column
            data['Ticker'] = ticker

            # Concatenate the current data with the existing DataFrame
            df_datos_1h = pd.concat([df_datos_1h, data])
        else:
            print(f"No 1-hour data found for ticker: {ticker}")

    except Exception as e:
        print(f"Error fetching 1-hour data for {ticker}: {e}")

# Print the DataFrame
df_datos_1h

# prompt: Rewrite the last cell but for 4h interval

import pandas as pd
df_datos_4h = pd.DataFrame()

# Iterate over each ticker in the lista_acciones DataFrame
for index, row in lista_acciones.iterrows():
    ticker = row['Ticker']

    try:
        # Get intraday data with 4-hour intervals using yfinance
        stock = yf.Ticker(ticker)
        # Use .history() for historical intraday data. As of recent yfinance versions, '4h' is a supported interval.
        data = stock.history(period="6mo", interval="4h") # Get 6 months of 4-hour data

        if not data.empty:
            # Add the ticker as a new column
            data['Ticker'] = ticker

            # Concatenate the current data with the existing DataFrame
            df_datos_4h = pd.concat([df_datos_4h, data])
        else:
            print(f"No 4-hour data found for ticker: {ticker}")

    except Exception as e:
        print(f"Error fetching 4-hour data for {ticker}: {e}")

# Print the DataFrame
df_datos_4h

# prompt: para cada ticker del dataframe df_datos_1h calcular la la SMA20 y SMA50

import pandas as pd

# Initialize empty lists to store SMA20 and SMA50 values
sma20_values = []
sma50_values = []
tickers_list = [] # List to store tickers that were processed successfully

# Iterate over each ticker in the df_datos_1h DataFrame
for ticker in df_datos_1h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_1h[df_datos_1h['Ticker'] == ticker].copy() # Use .copy() to avoid SettingWithCopyWarning

    # Ensure the 'Close' column exists before calculating SMAs
    if 'Close' in data_ticker.columns:
        # Calculate SMA20 and SMA50 for the current ticker
        sma20 = data_ticker['Close'].rolling(window=20).mean()
        sma50 = data_ticker['Close'].rolling(window=50).mean()

        # Check if there are enough data points to calculate SMAs
        if len(sma20) >= 20 and len(sma50) >= 50:
            # Extract the last values of SMA20 and SMA50
            sma20_last = sma20.iloc[-1]
            sma50_last = sma50.iloc[-1]

            # Append the values to the corresponding lists
            sma20_values.append(sma20_last)
            sma50_values.append(sma50_last)
            tickers_list.append(ticker) # Add ticker to the list
        else:
            print(f"Not enough data points to calculate SMAs for ticker: {ticker}. Skipping.")
    else:
        print(f"Column 'Close' not found for ticker: {ticker}. Skipping.")

# Create a new DataFrame to store the calculated values
# Use the tickers_list to ensure only processed tickers are included
df_sma1H = pd.DataFrame({
    'Ticker': tickers_list,
    'SMA20': sma20_values,
    'SMA50': sma50_values
})

# Print the new DataFrame
print(df_sma1H)

# prompt: Calcular la tendencia y crear un dataframe llamado df_tendencia1H

# prompt: Calcular la tendencia y crear un dataframe llamado df_tendencia1H

import pandas as pd
# Initialize an empty list to store the data for the new DataFrame
data = []

# Iterate over each ticker in the df_sma1H DataFrame
for index, row in df_sma1H.iterrows():
    ticker = row["Ticker"]
    sma20 = row["SMA20"]
    sma50 = row["SMA50"]

    # Determine the trend based on SMA20 and SMA50 values
    if sma20 > sma50:
        trend = "Alcista"
    elif sma20 < sma50:
        trend = "Bajista"
    else:
        trend = "Indeterminada"

    # Append the data for the current ticker to the list
    data.append({"Ticker": ticker, "Tendencia": trend})

# Create the df_tendencia1H DataFrame from the list of data
df_tendencia1H = pd.DataFrame(data)

# Print the df_tendencia1H DataFrame
print(df_tendencia1H)

# prompt: para cada ticker del dataframe df_datos_4h calcular SMA20 y SMA50 evitando las filas con volumen igual a cero

import pandas as pd
# Initialize empty lists to store SMA20 and SMA50 values
sma20_values = []
sma50_values = []
tickers_list = [] # List to store tickers that were processed successfully

# Iterate over each ticker in the df_datos_4h DataFrame
for ticker in df_datos_4h['Ticker'].unique():
    # Filter data for the current ticker and exclude rows with Volume == 0
    data_ticker = df_datos_4h[(df_datos_4h['Ticker'] == ticker) & (df_datos_4h['Volume'] != 0)].copy() # Use .copy() to avoid SettingWithCopyWarning

    # Ensure the 'Close' column exists before calculating SMAs
    if 'Close' in data_ticker.columns:
        # Calculate SMA20 and SMA50 for the current ticker on the filtered data
        sma20 = data_ticker['Close'].rolling(window=20).mean()
        sma50 = data_ticker['Close'].rolling(window=50).mean()

        # Check if there are enough data points to calculate SMAs after filtering
        # We need at least 50 data points (rows with Volume != 0) to calculate SMA50
        if len(data_ticker) >= 50: # Check the length of the filtered data
            # Extract the last values of SMA20 and SMA50
            sma20_last = sma20.iloc[-1]
            sma50_last = sma50.iloc[-1]

            # Append the values to the corresponding lists
            sma20_values.append(sma20_last)
            sma50_values.append(sma50_last)
            tickers_list.append(ticker) # Add ticker to the list
        else:
            print(f"Not enough data points with Volume != 0 to calculate SMAs for ticker: {ticker}. Need at least 50. Found {len(data_ticker)}. Skipping.")
    else:
        print(f"Column 'Close' not found for ticker: {ticker}. Skipping.")


# Create a new DataFrame to store the calculated values
# Use the tickers_list to ensure only processed tickers are included
df_sma4H = pd.DataFrame({
    'Ticker': tickers_list,
    'SMA20': sma20_values,
    'SMA50': sma50_values
})

# Print the new DataFrame
df_sma4H

# prompt: para cada ticker del dataframe df_datos_4h calcular la SMA20 y SMA50

import pandas as pd
# Initialize empty lists to store SMA20 and SMA50 values
sma20_values = []
sma50_values = []
tickers_list_4h = [] # List to store tickers that were processed successfully for 4h data

# Iterate over each ticker in the df_datos_4h DataFrame
for ticker in df_datos_4h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_4h[df_datos_4h['Ticker'] == ticker].copy() # Use .copy() to avoid SettingWithCopyWarning

    # Ensure the 'Close' column exists before calculating SMAs
    if 'Close' in data_ticker.columns:
        # Calculate SMA20 and SMA50 for the current ticker
        # Use 'Close' instead of '4. close'
        sma20 = data_ticker['Close'].rolling(window=20).mean()
        sma50 = data_ticker['Close'].rolling(window=50).mean()

        # Check if there are enough data points to calculate SMAs
        # We check if the number of non-null values is at least the window size
        if sma20.dropna().shape[0] >= 1 and sma50.dropna().shape[0] >= 1: # Check if there's at least one non-NaN value in the calculated series
            # Extract the last values of SMA20 and SMA50
            sma20_last = sma20.iloc[-1]
            sma50_last = sma50.iloc[-1]

            # Append the values to the corresponding lists
            sma20_values.append(sma20_last)
            sma50_values.append(sma50_last)
            tickers_list_4h.append(ticker) # Add ticker to the list
        else:
            print(f"Not enough data points to calculate SMAs for ticker: {ticker}. Skipping.")
    else:
        print(f"Column 'Close' not found for ticker: {ticker}. Skipping.")

# Create a new DataFrame to store the calculated values
# Use the tickers_list_4h to ensure only processed tickers are included
df_sma4H = pd.DataFrame({
    'Ticker': tickers_list_4h,
    'SMA20': sma20_values,
    'SMA50': sma50_values
})

# Print the new DataFrame
print(df_sma4H)

# prompt: Calcular la tendencia y crear un dataframe llamado df_tendencia4H

import pandas as pd
# Initialize an empty list to store the data for the new DataFrame
data = []

# Iterate over each ticker in the df_sma4H DataFrame
for index, row in df_sma4H.iterrows():
    ticker = row["Ticker"]
    sma20 = row["SMA20"]
    sma50 = row["SMA50"]

    # Determine the trend based on SMA20 and SMA50 values
    if sma20 > sma50:
        trend = "Alcista"
    elif sma20 < sma50:
        trend = "Bajista"
    else:
        trend = "Indeterminada"

    # Append the data for the current ticker to the list
    data.append({"Ticker": ticker, "Tendencia": trend})

# Create the df_tendencia4H DataFrame from the list of data
df_tendencia4H = pd.DataFrame(data)

# Print the df_tendencia4H DataFrame
print(df_tendencia4H)

# prompt: Crear una dataframe llamado df_tendencias con la tendencia diaria, de una hora y de cuatro horas

import pandas as pd
df_tendencias = pd.DataFrame(columns=["Ticker", "Tendencia diaria", "Tendencia 4H", "Tendencia 1H"])

# Use a list to store the data and create the DataFrame later
data = []
for ticker in df_tendencia_diaria["Ticker"]:
    data.append({
        "Ticker": ticker,
        "Tendencia diaria": df_tendencia_diaria[df_tendencia_diaria["Ticker"] == ticker]["Tendencia"].values[0],
        "Tendencia 4H": df_tendencia4H[df_tendencia4H["Ticker"] == ticker]["Tendencia"].values[0],
        "Tendencia 1H": df_tendencia1H[df_tendencia1H["Ticker"] == ticker]["Tendencia"].values[0]

    })

# Create the DataFrame from the data list
df_tendencias = pd.DataFrame(data)

print(df_tendencias)

# prompt: Reescribir esta última celda renombrando df_indicadores_tecnicos_lista a df_indicadores_tecnicos_diaria y df_recomendaciones_tecnicas a df_it_diaria_recomendation

import pandas as pd
# Recode this last cell using yfinance instead of AlphaVantage

# Función para obtener datos históricos
def get_historical_data(symbol):
    try:
        stock = yf.Ticker(symbol)
        # Get daily historical data for the last 1 year
        data = stock.history(period="1y")
        data = data.sort_index()  # Ensure data is sorted by date
        # Rename columns to match the expected format for ta library (optional, but good for consistency)
        # yfinance column names are already quite standard (Close, Open, High, Low, Volume)
        return data
    except Exception as e:
        print(f"Error getting historical data for {symbol}: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error


# Función para calcular indicadores técnicos
def calculate_technical_indicators(data):
    if data.empty or not all(col in data.columns for col in ['Close', 'High', 'Low']):
         print("Insufficient data to calculate technical indicators.")
         return pd.DataFrame() # Return empty if data is not valid or required columns are missing

    # Indicators from 'ta' library
    # Use yfinance column names (Close, High, Low)
    data['SMA_20'] = ta.trend.sma_indicator(data['Close'], window=20)
    data['SMA_50'] = ta.trend.sma_indicator(data['Close'], window=50)
    data['RSI'] = ta.momentum.rsi(data['Close'], window=14)
    data['MACD'] = ta.trend.macd(data['Close'])
    data['MACD_Signal'] = ta.trend.macd_signal(data['Close'])
    data['MACD_Diff'] = ta.trend.macd_diff(data['Close'])
    data['Bollinger_High'] = ta.volatility.bollinger_hband(data['Close'], window=20)
    data['Bollinger_Low'] = ta.volatility.bollinger_lband(data['Close'], window=20)
    data['Bollinger_Middle'] = ta.volatility.bollinger_mavg(data['Close'], window=20)
    data['ATR'] = ta.volatility.average_true_range(data['High'], data['Low'], data['Close'], window=14)
    return data

# Función para analizar los indicadores técnicos y devolver una recomendación
def analyze_indicators(data):
    # Ensure data has at least one row and required columns before accessing iloc[-1]
    if data.empty or not all(col in data.columns for col in ['RSI', 'MACD', 'MACD_Signal', 'SMA_20', 'SMA_50']):
        return 'Datos insuficientes para el análisis técnico'

    recommendations = []

    # Access the last row using iloc[-1]
    last_day_data = data.iloc[-1]

    # Check for NaN values before comparison
    if pd.notna(last_day_data['RSI']):
      # RSI thresholds
      if last_day_data['RSI'] < 30:
          recommendations.append('compra fuerte')
      elif last_day_data['RSI'] > 70:
          recommendations.append('venta fuerte')
      else:
          recommendations.append('mantener')
    else:
        recommendations.append('Datos RSI no disponibles')


    # MACD and MACD Signal
    if pd.notna(last_day_data['MACD']) and pd.notna(last_day_data['MACD_Signal']):
        if last_day_data['MACD'] > last_day_data['MACD_Signal']:
            recommendations.append('compra')
        else:
            recommendations.append('venta')
    else:
        recommendations.append('Datos MACD no disponibles')

    # SMA cross
    if pd.notna(last_day_data['SMA_20']) and pd.notna(last_day_data['SMA_50']):
        if last_day_data['SMA_20'] > last_day_data['SMA_50']:
            recommendations.append('compra')
        else:
            recommendations.append('venta')
    else:
        recommendations.append('Datos SMA no disponibles')


    # Aggregate recommendations
    buy_signals = recommendations.count('compra') + recommendations.count('compra fuerte')
    sell_signals = recommendations.count('venta') + recommendations.count('venta fuerte')
    # Consider "mantener" signals as neutral
    neutral_signals = recommendations.count('mantener')
    data_not_available_signals = recommendations.count('Datos RSI no disponibles') + recommendations.count('Datos MACD no disponibles') + recommendations.count('Datos SMA no disponibles')


    if buy_signals > sell_signals:
        if 'compra fuerte' in recommendations:
            return 'compra fuerte'
        return 'compra'
    elif sell_signals > buy_signals:
        if 'venta fuerte' in recommendations:
            return 'venta fuerte'
        return 'venta'
    elif neutral_signals > 0 and buy_signals == sell_signals:
        return 'mantener'
    elif data_not_available_signals > 0:
        return 'Datos insuficientes para un análisis completo'
    else:
        return 'indeterminada'


# Función para obtener y analizar los indicadores técnicos del último día
def get_and_analyze_last_day_indicators(symbol):
    data = get_historical_data(symbol)
    if data.empty:
        print(f"No historical data available for {symbol}. Skipping indicator calculation and analysis.")
        # Return empty DataFrame and "Datos insuficientes" recommendation
        return pd.DataFrame(), "Datos insuficientes"

    data = calculate_technical_indicators(data)
    if data.empty:
        print(f"Could not calculate technical indicators for {symbol}. Skipping analysis.")
        # Return the data (which might be empty) and "Datos insuficientes" recommendation
        return data, "Datos insuficientes"

    # Check if there is at least one row after calculating indicators
    if not data.empty:
      last_day_data = data.iloc[-1].copy()  # Get the last row and make a copy to avoid SettingWithCopyWarning
      recommendation = analyze_indicators(data)
      last_day_data['Ticker'] = symbol
      # Convert the last day data (Series) to a DataFrame for consistency
      df_indicadores_tecnicos_diaria = pd.DataFrame([last_day_data])
      return df_indicadores_tecnicos_diaria, recommendation
    else:
        print(f"Data became empty after calculating indicators for {symbol}. Skipping analysis.")
        return pd.DataFrame(), "Datos insuficientes"


# Example of use (you can iterate through lista_acciones['Ticker'] here)
# For a single ticker:
# symbol = 'AAPL'  # Replace with the stock symbol you want to analyze
# df_indicadores_tecnicos_diaria, recommendation = get_and_analyze_last_day_indicators(symbol)

# # Mostrar el DataFrame con los indicadores técnicos del último día y la recomendación
# print(df_indicadores_tecnicos_diaria)
# print(f"Recomendación: {recommendation}")

# To apply to all tickers in lista_acciones and store results in a DataFrame
df_indicadores_tecnicos_diaria = pd.DataFrame()
df_it_diaria_recomendation = pd.DataFrame(columns=["Ticker", "Recomendacion_tecnica"])

for ticker in lista_acciones['Ticker']:
    df_indicators, recommendation = get_and_analyze_last_day_indicators(ticker)

    # Add indicator data to the main indicator DataFrame
    if not df_indicators.empty:
        df_indicadores_tecnicos_diaria = pd.concat([df_indicadores_tecnicos_diaria, df_indicators], ignore_index=True)

    # Add recommendation to the recommendations DataFrame
    df_it_diaria_recomendation = pd.concat([df_it_diaria_recomendation, pd.DataFrame({"Ticker": [ticker], "Recomendacion_tecnica": [recommendation]})], ignore_index=True)

# Print the collected dataframes
print("\nIndicadores Técnicos del Último Día:")
print(df_indicadores_tecnicos_diaria)

print("\nRecomendaciones Técnicas:")
df_it_diaria_recomendation

df_indicadores_tecnicos_diaria

df_it_diaria_recomendation

# prompt: Agregar Recomendacion_tecnica a df_indicadores_tecnicos_diaria y renombrar la columna como  'Recomendacion'

import pandas as pd
df_indicadores_tecnicos_diaria = pd.merge(df_indicadores_tecnicos_diaria, df_it_diaria_recomendation, on='Ticker', how='left')
df_indicadores_tecnicos_diaria = df_indicadores_tecnicos_diaria.rename(columns={'Recomendacion_tecnica': 'Recomendacion'})

df_indicadores_tecnicos_diaria

# prompt: Renombrar df_indicadores_tecnicos_diaria y llamarlo df_it_diaria_recomendation

df_it_diaria_recomendation = df_indicadores_tecnicos_diaria

# prompt: Para cada ticker es df_datos_4h : calcular indicadores técnicos y guardar el resultado en un nuevo dataframe llamado df_indicadores_tecnicos_4h

# prompt: Para cada ticker es df_datos_4h : calcular indicadores técnicos y guardar el resultado en un nuevo dataframe llamado df_indicadores_tecnicos_4h

import pandas as pd
import ta # Make sure 'ta' is imported

# Define the function to calculate technical indicators.
# This function needs to be defined or imported before use.
# Based on the traceback, a function named 'calculate_technical_indicators' exists.
# We will assume this function needs to be modified to use the 'Close' column.

def calculate_technical_indicators(data):
    # Check if 'Close' column exists, which is the default name in yfinance history
    if 'Close' in data.columns:
        close_col = 'Close'
    # Fallback to '4. close' if the DataFrame might have been processed before or has a different origin
    elif '4. close' in data.columns:
        close_col = '4. close'
    else:
        # If neither column is found, return an empty DataFrame or raise an error
        print("Error: Neither 'Close' nor '4. close' column found in data.")
        return pd.DataFrame()

    # Calculate technical indicators using the identified close column
    # Ensure there are enough data points for rolling calculations
    if len(data) >= 50: # Assuming 50 is the largest window for SMA50
        data['SMA_20'] = ta.trend.sma_indicator(data[close_col], window=20)
        data['SMA_50'] = ta.trend.sma_indicator(data[close_col], window=50)
        data['RSI'] = ta.momentum.rsi(data[close_col], window=14)
    else:
        print(f"Warning: Not enough data points ({len(data)}) to calculate SMAs and RSI. Minimum required is 50.")
        # You might want to fill the indicator columns with NaN or return an empty DataFrame
        data['SMA_20'] = float('nan')
        data['SMA_50'] = float('nan')
        data['RSI'] = float('nan')

    return data

df_indicadores_tecnicos_4h = pd.DataFrame()

# Iterate over each ticker in the df_datos_4h DataFrame
for ticker in df_datos_4h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_4h[df_datos_4h['Ticker'] == ticker].copy() # Use .copy() to avoid SettingWithCopyWarning

    # Calculate technical indicators for the current ticker
    data_ticker = calculate_technical_indicators(data_ticker)

    # Check if the resulting data_ticker is not empty before proceeding
    if not data_ticker.empty and not data_ticker.iloc[-1].isnull().all(): # Also check if the last row is not all NaN
        # Get the last row of data for the current ticker
        last_day_data = data_ticker.iloc[-1]
        last_day_data['Ticker'] = ticker

        # Append the last day data to the df_indicadores_tecnicos_4h DataFrame
        df_indicadores_tecnicos_4h = pd.concat([df_indicadores_tecnicos_4h, pd.DataFrame([last_day_data])], ignore_index=True)
    else:
        print(f"Skipping ticker {ticker} due to insufficient data for indicator calculation.")


# Print the df_indicadores_tecnicos_4h DataFrame
print(df_indicadores_tecnicos_4h)

df_indicadores_tecnicos_4h

# prompt: Para cada ticker es df_datos_4h : calcular indicadores técnicos y guardar el resultado en un nuevo dataframe llamado df_indicadores_tecnicos_4h

# prompt: Para cada ticker es df_datos_4h : calcular indicadores técnicos y guardar el resultado en un nuevo dataframe llamado df_indicadores_tecnicos_4h

import pandas as pd
import ta # Make sure 'ta' is imported

# Define the function to calculate technical indicators.
# This function needs to be defined or imported before use.
# Based on the traceback, a function named 'calculate_technical_indicators' exists.
# We will assume this function needs to be modified to use the 'Close' column.

def calculate_technical_indicators(data):
    # Check if 'Close' column exists, which is the default name in yfinance history
    if 'Close' in data.columns:
        close_col = 'Close'
    # Fallback to '4. close' if the DataFrame might have been processed before or has a different origin
    elif '4. close' in data.columns:
        close_col = '4. close'
    else:
        # If neither column is found, return an empty DataFrame or raise an error
        print("Error: Neither 'Close' nor '4. close' column found in data.")
        return pd.DataFrame()

    # Calculate technical indicators using the identified close column
    # Ensure there are enough data points for rolling calculations
    # MACD typically requires at least 34 data points (26 + 9 for signal line)
    if len(data) >= 50: # Assuming 50 is the largest window for SMA50 and sufficient for MACD
        data['SMA_20'] = ta.trend.sma_indicator(data[close_col], window=20)
        data['SMA_50'] = ta.trend.sma_indicator(data[close_col], window=50)
        data['RSI'] = ta.momentum.rsi(data[close_col], window=14)

        # Calculate MACD and MACD Signal
        # Remove window_sign from macd function call
        macd = ta.trend.macd(data[close_col], window_slow=26, window_fast=12)
        macd_signal = ta.trend.macd_signal(data[close_col], window_slow=26, window_fast=12, window_sign=9)
        data['MACD'] = macd
        data['MACD_Signal'] = macd_signal

    else:
        print(f"Warning: Not enough data points ({len(data)}) to calculate SMAs, RSI, and MACD. Minimum required is around 34, but 50 is recommended for SMA50.")
        # You might want to fill the indicator columns with NaN or return an empty DataFrame
        data['SMA_20'] = float('nan')
        data['SMA_50'] = float('nan')
        data['RSI'] = float('nan')
        data['MACD'] = float('nan')
        data['MACD_Signal'] = float('nan')

    return data

# You also need to define the `analyze_indicators` function if it's not already defined elsewhere.
# Based on the traceback, this function exists and attempts to use MACD.
# Ensure this function is accessible in the current scope.

# Assuming analyze_indicators is defined as follows (or similar based on your existing code):
def analyze_indicators(data):
    recommendations = []

    # Check if indicators are available (not NaN)
    if pd.notna(data['SMA_20'].iloc[-1]) and pd.notna(data['SMA_50'].iloc[-1]) and \
       pd.notna(data['RSI'].iloc[-1]) and pd.notna(data['MACD'].iloc[-1]) and pd.notna(data['MACD_Signal'].iloc[-1]):

        # Simple Moving Averages
        if data['SMA_20'].iloc[-1] > data['SMA_50'].iloc[-1]:
            recommendations.append('compra')
        else:
            recommendations.append('venta')

        # RSI
        if data['RSI'].iloc[-1] < 30:
            recommendations.append('compra')
        elif data['RSI'].iloc[-1] > 70:
            recommendations.append('venta')
        else:
            recommendations.append('mantener')

        # MACD and MACD Signal
        if data['MACD'].iloc[-1] > data['MACD_Signal'].iloc[-1]:
            recommendations.append('compra')
        else:
            recommendations.append('venta')

        # Determine overall recommendation based on the majority
        from collections import Counter
        counts = Counter(recommendations)
        most_common = counts.most_common(1)[0][0]
        return most_common
    else:
        return "Indeterminada" # Return indeterminada if indicators are not available


df_indicadores_tecnicos_4h = pd.DataFrame()

# Iterate over each ticker in the df_datos_4h DataFrame
for ticker in df_datos_4h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_4h[df_datos_4h['Ticker'] == ticker].copy() # Use .copy() to avoid SettingWithCopyWarning

    # Calculate technical indicators for the current ticker
    data_ticker = calculate_technical_indicators(data_ticker)

    # Check if the resulting data_ticker is not empty and has enough data for analysis
    if not data_ticker.empty and len(data_ticker) >= 50: # Ensure enough data after indicator calculation
        # Get the last row of data for the current ticker
        last_day_data = data_ticker.iloc[-1]
        last_day_data['Ticker'] = ticker

        # Append the last day data to the df_indicadores_tecnicos_4h DataFrame
        df_indicadores_tecnicos_4h = pd.concat([df_indicadores_tecnicos_4h, pd.DataFrame([last_day_data])], ignore_index=True)
    else:
        print(f"Skipping ticker {ticker} due to insufficient data for indicator calculation and analysis.")


# Print the df_indicadores_tecnicos_4h DataFrame
print(df_indicadores_tecnicos_4h)

# prompt: analizar los indicadores técnicos y devolver una recomendación , guardar el resultado en un nuevo dataframe llamado df_it_4h_recomendation

import pandas as pd
df_it_4h_recomendation = pd.DataFrame()

# Iterate over each ticker in the df_datos_4h DataFrame
for ticker in df_datos_4h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_4h[df_datos_4h['Ticker'] == ticker].copy() # Use .copy() to avoid SettingWithCopyWarning

    # Calculate technical indicators for the current ticker
    data_ticker = calculate_technical_indicators(data_ticker)

    # Check if the resulting data_ticker is not empty and has enough data for analysis
    if not data_ticker.empty and len(data_ticker) >= 50: # Ensure enough data after indicator calculation
        # Get the last row of data for the current ticker
        last_row_data = data_ticker.iloc[-1]

        # Analyze the technical indicators and get the recommendation
        # Pass the entire data_ticker DataFrame to analyze_indicators
        recommendation = analyze_indicators(data_ticker)

        # Store the recommendation in the last_row_data Series
        last_row_data['Ticker'] = ticker
        last_row_data['Recomendacion'] = recommendation

        # Append the last row data to the df_it_4h_recomendation DataFrame
        df_it_4h_recomendation = pd.concat([df_it_4h_recomendation, pd.DataFrame([last_row_data])], ignore_index=True)
    else:
        print(f"Skipping ticker {ticker} for 4h recommendation due to insufficient data for indicator calculation and analysis.")

# Print the df_it_4h_recomendation DataFrame
df_it_4h_recomendation

df_it_4h_recomendation

# prompt: Para cada ticker es df_datos_1h : calcular indicadores técnicos y guardar el resultado en un nuevo dataframe llamado df_indicadores_tecnicos_1h

import pandas as pd
df_indicadores_tecnicos_1h = pd.DataFrame()

# Iterate over each ticker in the df_datos_1h DataFrame
for ticker in df_datos_1h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_1h[df_datos_1h['Ticker'] == ticker]

    # Calculate technical indicators for the current ticker
    data_ticker = calculate_technical_indicators(data_ticker)

    # Get the last day data for the current ticker
    last_day_data = data_ticker.iloc[-1]
    last_day_data['Ticker'] = ticker

    # Append the last day data to the df_indicadores_tecnicos_1h DataFrame
    df_indicadores_tecnicos_1h = pd.concat([df_indicadores_tecnicos_1h, pd.DataFrame([last_day_data])], ignore_index=True)

# Print the df_indicadores_tecnicos_1h DataFrame
print(df_indicadores_tecnicos_1h)

df_indicadores_tecnicos_1h

# prompt: analizar los indicadores técnicos y devolver una recomendación , guardar el resultado en un nuevo dataframe llamado df_it_1h_recomendation

import pandas as pd
df_it_1h_recomendation = pd.DataFrame()

# Iterate over each ticker in the df_datos_1h DataFrame
for ticker in df_datos_1h['Ticker'].unique():
    # Filter data for the current ticker
    data_ticker = df_datos_1h[df_datos_1h['Ticker'] == ticker]

    # Calculate technical indicators for the current ticker
    data_ticker = calculate_technical_indicators(data_ticker)

    # Get the last day data for the current ticker
    last_day_data = data_ticker.iloc[-1]
    last_day_data['Ticker'] = ticker

    # Analyze the technical indicators and get the recommendation
    recommendation = analyze_indicators(data_ticker)

    # Store the recommendation in the last_day_data DataFrame
    last_day_data['Recomendacion'] = recommendation

    # Append the last day data to the df_it_1h_recomendation DataFrame
    df_it_1h_recomendation = pd.concat([df_it_1h_recomendation, pd.DataFrame([last_day_data])], ignore_index=True)

# Print the df_it_1h_recomendation DataFrame
print(df_it_1h_recomendation)

df_it_1h_recomendation

# prompt: Crear un nuevo dataframe llamado df_it_recomendation_final con el ticker, y la columna 'Recomendacion' de df_it_diaria_recomendation, df_it_4h_recomendation y df_it_1h_recomendation
# prompt: Crear un nuevo dataframe llamado df_it_recomendation_final con el ticker, y la columna 'Recomendacion' de df_it_diaria_recomendation, df_it_4h_recomendation y df_it_1h_recomendation

import pandas as pd
df_it_recomendation_final = pd.DataFrame(columns=['Ticker', 'Recomendacion_diaria', 'Recomendacion_4h', 'Recomendacion_1h'])

# Iterate over each ticker in the lista_acciones DataFrame
for ticker in lista_acciones["Ticker"]:
    # Get the recommendation from each timeframe
    recomendacion_diaria = df_it_diaria_recomendation[df_it_diaria_recomendation['Ticker'] == ticker]['Recomendacion'].values[0]
    recomendacion_4h = df_it_4h_recomendation[df_it_4h_recomendation['Ticker'] == ticker]['Recomendacion'].values[0]
    recomendacion_1h = df_it_1h_recomendation[df_it_1h_recomendation['Ticker'] == ticker]['Recomendacion'].values[0]

    # Create a new row with the ticker and recommendations
    new_row = {'Ticker': ticker, 'Recomendacion_diaria': recomendacion_diaria, 'Recomendacion_4h': recomendacion_4h, 'Recomendacion_1h': recomendacion_1h}

    # Append the new row to the df_it_recomendation_final DataFrame using pd.concat
    df_it_recomendation_final = pd.concat([df_it_recomendation_final, pd.DataFrame([new_row])], ignore_index=True)

# Print the df_it_recomendation_final DataFrame
print(df_it_recomendation_final)

# prompt: df_tendencias, df_it_recomendation_final, df_it_diaria_recomendation, df_it_4h_recomendation, df_it_1h_recomendation, juntar todos en un nuevo dataframe llamado df_analisistecnico_total. Un dataframe por hoja.

# prompt: df_tendencias, df_it_recomendation_final, df_it_diaria_recomendation, df_it_4h_recomendation, df_it_1h_recomendation, juntar todos en un nuevo dataframe llamado df_analisistecnico_total. Un dataframe por hoja.

import pandas as pd
df_analisistecnico_total = pd.DataFrame()

# Concatenate the dataframes horizontally
df_analisistecnico_total = pd.concat([df_tendencias, df_it_recomendation_final, df_it_diaria_recomendation, df_it_4h_recomendation, df_it_1h_recomendation], axis=1)

# Create a new Excel file
import xlsxwriter # Import the xlsxwriter module
with pd.ExcelWriter('analisistecnico_total.xlsx', engine='xlsxwriter') as writer:
    # Write each dataframe to a separate sheet
    df_tendencias.to_excel(writer, sheet_name='Tendencias')
    df_it_recomendation_final.to_excel(writer, sheet_name='Recomendaciones')
    df_it_diaria_recomendation.to_excel(writer, sheet_name='Recomendaciones_Diarias')
    df_it_4h_recomendation.to_excel(writer, sheet_name='Recomendaciones_4h')
    df_it_1h_recomendation.to_excel(writer, sheet_name='Recomendaciones_1h')

    # Save and close the Excel file using the close method
    writer.close() # Use close() instead of save()

df_analisistecnico_total

"""ESTRATEGIA RSI 2 DE CONNORS"""

# Coloca tu API key de Alpha Vantage aquí
#API_KEY = 'KENCH2JI7182TUIK'

# Función para obtener datos históricos en temporalidad diaria
def get_historical_data(symbol):
    ts = TimeSeries(key=API_KEY, output_format='pandas')
    data, _ = ts.get_daily(symbol=symbol, outputsize='compact')
    data = data.sort_index()  # Asegúrate de que los datos estén ordenados por fecha
    return data

# Función para calcular indicadores técnicos necesarios
def calculate_indicators(data):
    # Calcular las medias móviles de 200 y 5 períodos
    data['SMA_200'] = ta.trend.sma_indicator(data['4. close'], window=200)
    data['SMA_5'] = ta.trend.sma_indicator(data['4. close'], window=5)

    # Calcular el RSI2
    data['RSI2'] = ta.momentum.rsi(data['4. close'], window=2)

    return data

# Función para evaluar la estrategia RSI2 de Connors y devolver la señal
def evaluate_rsi2_strategy(data):
    last_day = data.iloc[-1]  # Obtiene los datos del último día

    close = last_day['4. close']
    sma_200 = last_day['SMA_200']
    sma_5 = last_day['SMA_5']
    rsi2 = last_day['RSI2']

    if close > sma_200 and close < sma_5 and 0 <= rsi2 <= 10:
        return 'señal de compra'
    elif close < sma_200 and close > sma_5 and 90 <= rsi2 <= 100:
        return 'señal de venta'
    else:
        return 'ninguna señal'

# Función principal para obtener datos, calcular indicadores y evaluar la estrategia
def rsi2_connors_strategy(symbol):
    data = get_historical_data(symbol)
    data = calculate_indicators(data)
    signal = evaluate_rsi2_strategy(data)
    return signal

# Ejemplo de uso
#symbol = 'kspi'  # Reemplaza con el símbolo de la acción que deseas analizar
#signal = rsi2_connors_strategy(symbol)

# Mostrar la señal generada
#print(f"Señal para {symbol}: {signal}")

# prompt: Rescribir esta útlima celda utilizando yfinance en vez de Alphavantage

import pandas as pd
# ESTRATEGIA RSI 2 DE CONNORS - Using yfinance
# No API Key is needed for yfinance

# Function to get historical data in daily timeframe using yfinance
def get_historical_data_yf(symbol):
    try:
        stock = yf.Ticker(symbol)
        # Get daily historical data
        data = stock.history(period="1y") # Fetch data for the last 1 year (or adjust period as needed)
        data = data.sort_index()  # Ensure data is sorted by date
        # Rename columns to match the expected format (yfinance uses different names)
        data = data.rename(columns={'Close': '4. close', 'Open': '1. open', 'High': '2. high', 'Low': '3. low', 'Volume': '5. volume'})
        return data
    except Exception as e:
        print(f"Error getting historical data for {symbol}: {e}")
        return pd.DataFrame() # Return an empty DataFrame on error

# Function to calculate necessary technical indicators using 'ta' library
def calculate_indicators_ta(data):
    if data.empty or '4. close' not in data.columns:
        return pd.DataFrame() # Return empty if data is not valid

    # Calculate the 200 and 5 period moving averages
    data['SMA_200'] = ta.trend.sma_indicator(data['4. close'], window=200)
    data['SMA_5'] = ta.trend.sma_indicator(data['4. close'], window=5)

    # Calculate the RSI2
    data['RSI2'] = ta.momentum.rsi(data['4. close'], window=2)

    return data

# Function to evaluate the Connors RSI2 strategy and return the signal
def evaluate_rsi2_strategy(data):
    if data.empty or 'SMA_200' not in data.columns or 'SMA_5' not in data.columns or 'RSI2' not in data.columns:
        return 'Data or indicators missing' # Return error if data or indicators are missing

    last_day = data.iloc[-1]  # Get the last day's data

    close = last_day['4. close']
    sma_200 = last_day['SMA_200']
    sma_5 = last_day['SMA_5']
    rsi2 = last_day['RSI2']

    # Ensure indicators are not NaN before evaluating
    if pd.notna(close) and pd.notna(sma_200) and pd.notna(sma_5) and pd.notna(rsi2):
        if close > sma_200 and close < sma_5 and 0 <= rsi2 <= 10:
            return 'señal de compra'
        elif close < sma_200 and close > sma_5 and 90 <= rsi2 <= 100:
            return 'señal de venta'
        else:
            return 'ninguna señal'
    else:
        return 'Indicators Not Available' # Return if indicators are NaN

# Main function to get data, calculate indicators, and evaluate the strategy
def rsi2_connors_strategy_yf(symbol):
    data = get_historical_data_yf(symbol)
    if not data.empty:
        data = calculate_indicators_ta(data)
        signal = evaluate_rsi2_strategy(data)
        return signal
    else:
        return 'Error fetching data'

# Example of use (you can iterate through lista_acciones['Ticker'] here)
# symbol = 'MSFT'  # Replace with the stock symbol you want to analyze
# signal = rsi2_connors_strategy_yf(symbol)

# Show the generated signal
# print(f"Señal para {symbol}: {signal}")

# prompt: evaluar la estrategia RSI 2 de connors para cada ticker en lista_acciones y crear un nuevo dataframe llamado df_it_rsi2_connors con el ticker y la señal de cada ticker
#API_KEY = 'WVVQPK40JLHF3A5Y'
import pandas as pd
df_it_rsi2_connors = pd.DataFrame(columns=['Ticker', 'Señal RSI2 Connors'])

# Iterate over each ticker in the lista_acciones DataFrame
for ticker in lista_acciones["Ticker"]:
    # Get the signal for the current ticker
    # Call the yfinance version of the strategy function
    signal = rsi2_connors_strategy_yf(ticker)

    # Create a new row with the ticker and signal
    new_row = {'Ticker': ticker, 'Señal RSI2 Connors': signal}

    # Append the new row to the df_it_rsi2_connors DataFrame
    df_it_rsi2_connors = pd.concat([df_it_rsi2_connors, pd.DataFrame([new_row])], ignore_index=True)

# Print the df_it_rsi2_connors DataFrame
print(df_it_rsi2_connors)

# prompt: hacerlo para los últimos 7 días y crear un nuevo dataframe con las señales con fecha y señal, usar yfinance en vez de Alphavantage

import pandas as pd
from datetime import datetime, timedelta

# Create a new DataFrame to store the signals
df_connors_signals_last_7_days = pd.DataFrame(columns=['Fecha', 'Ticker', 'Señal RSI2 Connors'])

# Get the date 7 days ago from today
end_date = datetime.today()
start_date = end_date - timedelta(days=7)

# Iterate over each ticker in the lista_acciones DataFrame
for ticker in lista_acciones["Ticker"]:
    try:
        # Get daily historical data using yfinance for the last 7 days
        stock = yf.Ticker(ticker)
        data = stock.history(start=start_date, end=end_date, interval="1d")

        if not data.empty:
            # Rename columns to match the expected format (yfinance uses different names)
            data = data.rename(columns={'Close': '4. close', 'Open': '1. open', 'High': '2. high', 'Low': '3. low', 'Volume': '5. volume'})

            # Calculate technical indicators for the data (including lookback for SMAs)
            # Fetch enough data for SMA200 and SMA5 calculations even if we only analyze the last 7 days for signals
            # Let's fetch a bit more history to ensure SMA calculations are valid
            data_for_indicators = stock.history(period="1y", interval="1d") # Fetch 1 year of data for indicators
            data_for_indicators = data_for_indicators.rename(columns={'Close': '4. close', 'Open': '1. open', 'High': '2. high', 'Low': '3. low', 'Volume': '5. volume'})

            data_for_indicators = calculate_indicators_ta(data_for_indicators)

            # Iterate through the last 7 days of fetched data
            for date, row in data.iterrows():
                # To evaluate the signal for a specific date, we need the data up to that date
                data_up_to_date = data_for_indicators.loc[:date].copy()

                # Ensure there is enough data for the indicators calculation
                if len(data_up_to_date) >= 200: # Need at least 200 data points for SMA200
                    # Re-calculate indicators up to the current date if needed, or use the pre-calculated ones if the main dataframe was large enough
                    # For simplicity and accuracy for each specific day, recalculating on the subset up to that day is better
                    data_up_to_date = calculate_indicators_ta(data_up_to_date)


                    # Evaluate the strategy for the current date
                    signal = evaluate_rsi2_strategy(data_up_to_date)

                    # Append the date, ticker, and signal to the new DataFrame
                    new_row = {'Fecha': date.date(), 'Ticker': ticker, 'Señal RSI2 Connors': signal}
                    df_connors_signals_last_7_days = pd.concat([df_connors_signals_last_7_days, pd.DataFrame([new_row])], ignore_index=True)
                else:
                    # Append with "Not enough data" if indicators cannot be calculated
                    new_row = {'Fecha': date.date(), 'Ticker': ticker, 'Señal RSI2 Connors': "Not enough data for indicators"}
                    df_connors_signals_last_7_days = pd.concat([df_connors_signals_last_7_days, pd.DataFrame([new_row])], ignore_index=True)

        else:
            print(f"No historical data found for ticker: {ticker} in the last 7 days.")
            # Append with "No data" if no historical data is found in the last 7 days
            new_row = {'Fecha': None, 'Ticker': ticker, 'Señal RSI2 Connors': "No data in the last 7 days"}
            df_connors_signals_last_7_days = pd.concat([df_connors_signals_last_7_days, pd.DataFrame([new_row])], ignore_index=True)

    except Exception as e:
        print(f"Error processing ticker {ticker}: {e}")
        # Append with error message
        new_row = {'Fecha': None, 'Ticker': ticker, 'Señal RSI2 Connors': f"Error: {e}"}
        df_connors_signals_last_7_days = pd.concat([df_connors_signals_last_7_days, pd.DataFrame([new_row])], ignore_index=True)

# Print the DataFrame with signals for the last 7 days
df_connors_signals_last_7_days

df_connors_signals_last_7_days

# prompt: Convertir df_connors_signals_last_7_days en un archivo excel

df_connors_signals_last_7_days.to_excel('connors_signals_last_7_days.xlsx', index=False)